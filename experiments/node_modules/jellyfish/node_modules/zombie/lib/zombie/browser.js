// Generated by CoffeeScript 1.3.1
var BROWSER_OPTIONS, Browser, Cache, Cookies, EventEmitter, EventLoop, FS, GLOBAL_OPTIONS, HTML, HTML5, Interact, JSDOM, MOUSE_EVENT_NAMES, Mime, PACKAGE, Path, Resources, Storages, URL, VERSION, Windows, XHR, deprecated,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

require("./jsdom_patches");

require("./forms");

require("./xpath");

deprecated = require("./helpers").deprecated;

Cache = require("./cache");

Cookies = require("./cookies");

EventEmitter = require("events").EventEmitter;

EventLoop = require("./eventloop");

FS = require("fs");

HTML5 = require("html5").HTML5;

Interact = require("./interact");

JSDOM = require("jsdom");

Mime = require("mime");

Path = require("path");

Resources = require("./resources");

Storages = require("./storage");

URL = require("url");

Windows = require("./windows");

XHR = require("./xhr");

BROWSER_OPTIONS = ["credentials", "debug", "htmlParser", "loadCSS", "proxy", "referer", "runScripts", "silent", "site", "userAgent", "waitFor", "name"];

GLOBAL_OPTIONS = ["debug", "htmlParser", "loadCSS", "proxy", "runScripts", "silent", "site", "userAgent", "waitFor"];

PACKAGE = JSON.parse(require("fs").readFileSync(__dirname + "/../../package.json"));

VERSION = PACKAGE.version;

HTML = JSDOM.dom.level3.html;

MOUSE_EVENT_NAMES = ["mousedown", "mousemove", "mouseup"];

Browser = (function(_super) {

  __extends(Browser, _super);

  Browser.name = 'Browser';

  function Browser(options) {
    var name, value, _i, _len,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._cache = new Cache();
    this._cookies = new Cookies();
    this._eventloop = new EventLoop(this);
    this._storages = new Storages();
    this._interact = Interact.use(this);
    this._xhr = XHR.use(this._cache);
    this.on("error", function(error) {
      _this.errors.push(error);
      return _this.log(error.message, error.stack);
    });
    this.credentials = false;
    this.debug = false;
    this.htmlParser = HTML5;
    this.loadCSS = true;
    this.proxy = null;
    this.referer = void 0;
    this.runScripts = true;
    this.silent = false;
    this.userAgent = "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/" + VERSION;
    this.site = void 0;
    this.waitFor = 500;
    this.name = "nodejs";
    for (_i = 0, _len = BROWSER_OPTIONS.length; _i < _len; _i++) {
      name = BROWSER_OPTIONS[_i];
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      }
      if (!this[name] && ~GLOBAL_OPTIONS.indexOf(name)) {
        if (value = Browser[name]) {
          this[name] = value;
        }
      }
    }
    this.errors = [];
    this.resources = new Resources(this);
    this.windows = new Windows(this);
  }

  Browser.prototype.withOptions = function(options, fn) {
    var k, restore, v, _ref,
      _this = this;
    if (options) {
      restore = {};
      for (k in options) {
        v = options[k];
        _ref = [this[k], v], restore[k] = _ref[0], this[k] = _ref[1];
      }
    }
    return fn(function() {
      var k, v, _results;
      if (restore) {
        _results = [];
        for (k in restore) {
          v = restore[k];
          _results.push(_this[k] = v);
        }
        return _results;
      }
    });
  };

  Browser.prototype.fork = function() {
    var forked;
    forked = new Browser();
    forked.loadCookies(this.saveCookies());
    forked.loadStorage(this.saveStorage());
    forked.loadHistory(this.saveHistory());
    return forked;
  };

  Browser.prototype.__defineGetter__("window", function() {
    return this.windows.current;
  });

  Browser.prototype.open = function(options) {
    this._eventloop.reset();
    this.errors = [];
    this.resources.clear();
    return this.windows.open(options || {});
  };

  Browser.prototype.__defineGetter__("error", function() {
    return this.errors[this.errors.length - 1];
  });

  Browser.prototype.wait = function(duration, callback) {
    var completed, _ref,
      _this = this;
    if (!callback && typeof duration === "function") {
      _ref = [duration, null], callback = _ref[0], duration = _ref[1];
    }
    completed = function(error) {
      if (callback) {
        (function(callback) {
          return process.nextTick(function() {
            return callback(error, _this);
          });
        })(callback);
        return callback = null;
      }
    };
    this.once("done", completed);
    this.once("error", completed);
    this._eventloop.wait(this.window, duration);
  };

  Browser.prototype.fire = function(name, target, callback) {
    var event, type;
    type = __indexOf.call(MOUSE_EVENT_NAMES, name) >= 0 ? "MouseEvents" : "HTMLEvents";
    event = this.window.document.createEvent(type);
    event.initEvent(name, true, true);
    this.dispatchEvent(target, event);
    if (callback) {
      return this.wait(function(error, browser) {
        return callback(error, browser, event);
      });
    } else {
      return this;
    }
  };

  Browser.prototype.dispatchEvent = function(target, event) {
    return this._eventloop.dispatch(target, event);
  };

  Browser.prototype.queryAll = function(selector, context) {
    var ret;
    context || (context = this.document.documentElement);
    if (selector) {
      ret = context.querySelectorAll(selector);
      return Array.prototype.slice.call(ret, 0);
    } else {
      return [context];
    }
  };

  Browser.prototype.query = function(selector, context) {
    context || (context = this.document.documentElement);
    if (selector) {
      return context.querySelector(selector);
    } else {
      return context;
    }
  };

  Browser.prototype.$$ = function(selector, context) {
    return this.query(selector, context);
  };

  Browser.prototype.querySelector = function(selector) {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelector(selector) : void 0;
  };

  Browser.prototype.querySelectorAll = function(selector) {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelectorAll(selector) : void 0;
  };

  Browser.prototype.text = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function(e) {
        return e.textContent;
      }).join("").trim();
    }
    return this.source;
  };

  Browser.prototype.html = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function(e) {
        return e.outerHTML.trim();
      }).join("");
    }
    return this.source;
  };

  Browser.prototype.css = function(selector, context) {
    deprecated("Browser.css is deprecated, please use browser.query and browser.queryAll instead.");
    return this.queryAll(selector, context);
  };

  Browser.prototype.xpath = function(expression, context) {
    return this.document.evaluate(expression, context || this.document.documentElement);
  };

  Browser.prototype.__defineGetter__("document", function() {
    var _ref;
    return (_ref = this.window) != null ? _ref.document : void 0;
  });

  Browser.prototype.__defineGetter__("body", function() {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelector("body") : void 0;
  });

  Browser.prototype.__defineGetter__("statusCode", function() {
    var _ref;
    return (_ref = this.response) != null ? _ref[0] : void 0;
  });

  Browser.prototype.__defineGetter__("success", function() {
    return this.statusCode >= 200 && this.statusCode < 300;
  });

  Browser.prototype.__defineGetter__("redirected", function() {
    var _ref, _ref1;
    return !!((_ref = this.resources.last) != null ? (_ref1 = _ref.response) != null ? _ref1.redirected : void 0 : void 0);
  });

  Browser.prototype.__defineGetter__("source", function() {
    var _ref;
    return (_ref = this.response) != null ? _ref[2] : void 0;
  });

  Browser.prototype.visit = function(url, options, callback) {
    var duration, _ref, _ref1,
      _this = this;
    if (typeof options === "function" && !callback) {
      _ref = [options, null], callback = _ref[0], options = _ref[1];
    }
    if (typeof options !== "object") {
      _ref1 = [options, null], duration = _ref1[0], options = _ref1[1];
    }
    this.withOptions(options, function(reset_options) {
      var site;
      if (site = _this.site) {
        if (!/^(https?:|file:)/i.test(site)) {
          site = "http://" + site;
        }
        url = URL.resolve(site, URL.parse(URL.format(url)));
      }
      _this.window.history._assign(url);
      if (callback) {
        return _this.wait(duration, function(error, browser) {
          reset_options();
          return callback(error, browser, browser.statusCode, browser.errors);
        });
      } else {
        return reset_options();
      }
    });
  };

  Browser.prototype.__defineGetter__("location", function() {
    return this.window.location;
  });

  Browser.prototype.__defineSetter__("location", function(url) {
    return this.window.location = url;
  });

  Browser.prototype.link = function(selector) {
    var link, _i, _len, _ref;
    if (link = this.querySelector(selector)) {
      if (link.tagName === "A") {
        return link;
      }
    }
    _ref = this.querySelectorAll("body a");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      if (link.textContent.trim() === selector) {
        return link;
      }
    }
  };

  Browser.prototype.clickLink = function(selector, callback) {
    var link,
      _this = this;
    if (link = this.link(selector)) {
      return this.fire("click", link, function() {
        return callback(null, _this, _this.statusCode);
      });
    } else {
      throw new Error("No link matching '" + selector + "'");
    }
  };

  Browser.prototype.__defineGetter__("history", function() {
    return this.window.history;
  });

  Browser.prototype.back = function(callback) {
    this.window.history.back();
    if (callback) {
      return this.wait(callback);
    }
  };

  Browser.prototype.reload = function(callback) {
    this.window.location.reload();
    if (callback) {
      return this.wait(callback);
    }
  };

  Browser.prototype.saveHistory = function() {
    return this.window.history.save();
  };

  Browser.prototype.loadHistory = function(serialized) {
    return this.window.history.load(serialized);
  };

  Browser.prototype.field = function(selector) {
    var field, for_attr, label, _i, _len, _ref;
    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (field = this.querySelector(selector)) {
      if (field.tagName === "INPUT" || field.tagName === "TEXTAREA" || field.tagName === "SELECT") {
        return field;
      }
    }
    if (field = this.querySelector(":input[name='" + selector + "']")) {
      return field;
    }
    _ref = this.querySelectorAll("label");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      label = _ref[_i];
      if (label.textContent.trim() === selector) {
        if (for_attr = label.getAttribute("for")) {
          return this.document.getElementById(for_attr);
        } else {
          return label.querySelector(":input");
        }
      }
    }
  };

  Browser.prototype.fill = function(selector, value, callback) {
    var field;
    field = this.field(selector);
    if (field && (field.tagName === "TEXTAREA" || (field.tagName === "INPUT"))) {
      if (field.getAttribute("disabled")) {
        throw new Error("This INPUT field is disabled");
      }
      if (field.getAttribute("readonly")) {
        throw new Error("This INPUT field is readonly");
      }
      field.value = value;
      this.fire("change", field, callback);
      if (!callback) {
        return this;
      }
    } else {
      throw new Error("No INPUT matching '" + selector + "'");
    }
  };

  Browser.prototype._setCheckbox = function(selector, value, callback) {
    var field;
    field = this.field(selector);
    if (field && field.tagName === "INPUT" && field.type === "checkbox") {
      if (field.getAttribute("disabled")) {
        throw new Error("This INPUT field is disabled");
      }
      if (field.getAttribute("readonly")) {
        throw new Error("This INPUT field is readonly");
      }
      if (field.checked ^ value) {
        field.click();
      }
      if (callback) {
        return this.wait(callback);
      } else {
        return this;
      }
    } else {
      throw new Error("No checkbox INPUT matching '" + selector + "'");
    }
  };

  Browser.prototype.check = function(selector, callback) {
    return this._setCheckbox(selector, true, callback);
  };

  Browser.prototype.uncheck = function(selector, callback) {
    return this._setCheckbox(selector, false, callback);
  };

  Browser.prototype.choose = function(selector, callback) {
    var field;
    field = this.field(selector) || this.field("input[type=radio][value=\"" + (escape(selector)) + "\"]");
    if (field && field.tagName === "INPUT" && field.type === "radio") {
      field.click();
      if (callback) {
        return this.wait(callback);
      } else {
        return this;
      }
    } else {
      throw new Error("No radio INPUT matching '" + selector + "'");
    }
  };

  Browser.prototype._findOption = function(selector, value) {
    var field, option, _i, _j, _len, _len1, _ref, _ref1;
    field = this.field(selector);
    if (field && field.tagName === "SELECT") {
      if (field.getAttribute("disabled")) {
        throw new Error("This SELECT field is disabled");
      }
      if (field.getAttribute("readonly")) {
        throw new Error("This SELECT field is readonly");
      }
      _ref = field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.value === value) {
          return option;
        }
      }
      _ref1 = field.options;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        option = _ref1[_j];
        if (option.label === value) {
          return option;
        }
      }
      throw new Error("No OPTION '" + value + "'");
    } else {
      throw new Error("No SELECT matching '" + selector + "'");
    }
  };

  Browser.prototype.attach = function(selector, filename, callback) {
    var field, file, stat;
    field = this.field(selector);
    if (field && field.tagName === "INPUT" && field.type === "file") {
      if (filename) {
        stat = FS.statSync(filename);
        file = new this.window.File();
        file.name = Path.basename(filename);
        file.type = Mime.lookup(filename);
        file.size = stat.size;
        field.files || (field.files = []);
        field.files.push(file);
        field.value = filename;
        this.fire("change", field, callback);
      }
    } else {
      throw new Error("No file INPUT matching '" + selector + "'");
    }
    if (!callback) {
      return this;
    }
  };

  Browser.prototype.select = function(selector, value, callback) {
    var option;
    option = this._findOption(selector, value);
    return this.selectOption(option, callback);
  };

  Browser.prototype.selectOption = function(option, callback) {
    var select;
    if (option && !option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).value[0];
      option.setAttribute("selected", "selected");
      return this.fire("change", select, callback);
    } else if (callback) {
      return callback(null, false);
    } else {
      return this;
    }
  };

  Browser.prototype.unselect = function(selector, value, callback) {
    var option;
    option = this._findOption(selector, value);
    return this.unselectOption(option, callback);
  };

  Browser.prototype.unselectOption = function(option, callback) {
    var select;
    if (option && option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).value[0];
      if (!select.multiple) {
        throw new Error("Cannot unselect in single select");
      }
      option.removeAttribute("selected");
      return this.fire("change", select, callback);
    } else if (callback) {
      return callback(null, false);
    } else {
      return this;
    }
  };

  Browser.prototype.button = function(selector) {
    var button, input, inputs, _i, _j, _k, _len, _len1, _len2, _ref;
    if (button = this.querySelector(selector)) {
      if (button.tagName === "BUTTON" || button.tagName === "INPUT") {
        return button;
      }
    }
    _ref = this.querySelectorAll("form button");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      button = _ref[_i];
      if (button.textContent.trim() === selector) {
        return button;
      }
    }
    inputs = this.querySelectorAll("form :submit, form :reset, form :button");
    for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
      input = inputs[_j];
      if (input.name === selector) {
        return input;
      }
    }
    for (_k = 0, _len2 = inputs.length; _k < _len2; _k++) {
      input = inputs[_k];
      if (input.value === selector) {
        return input;
      }
    }
  };

  Browser.prototype.pressButton = function(selector, callback) {
    var button;
    if (button = this.button(selector)) {
      if (button.getAttribute("disabled")) {
        throw new Error("This button is disabled");
      } else {
        return this.fire("click", button, callback);
      }
    } else {
      throw new Error("No BUTTON '" + selector + "'");
    }
  };

  Browser.prototype.cookies = function(domain, path) {
    return this._cookies.access(domain || this.location.hostname, path || this.location.pathname);
  };

  Browser.prototype.saveCookies = function() {
    return this._cookies.save();
  };

  Browser.prototype.loadCookies = function(serialized) {
    return this._cookies.load(serialized);
  };

  Browser.prototype.localStorage = function(host) {
    return this._storages.local(host);
  };

  Browser.prototype.sessionStorage = function(host) {
    return this._storages.session(host);
  };

  Browser.prototype.saveStorage = function() {
    return this._storages.save();
  };

  Browser.prototype.loadStorage = function(serialized) {
    return this._storages.load(serialized);
  };

  Browser.prototype.evaluate = function(code, filename) {
    return this.window._evaluate(code, filename);
  };

  Browser.prototype.onalert = function(fn) {
    return this._interact.onalert(fn);
  };

  Browser.prototype.onconfirm = function(question, response) {
    return this._interact.onconfirm(question, response);
  };

  Browser.prototype.onprompt = function(message, response) {
    return this._interact.onprompt(message, response);
  };

  Browser.prototype.prompted = function(message) {
    return this._interact.prompted(message);
  };

  Browser.prototype.viewInBrowser = function(browser) {
    return require("./bcat").bcat(this.html());
  };

  Browser.prototype.__defineGetter__("lastRequest", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.request : void 0;
  });

  Browser.prototype.__defineGetter__("lastResponse", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.response : void 0;
  });

  Browser.prototype.__defineGetter__("lastError", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.error : void 0;
  });

  Browser.prototype.log = function() {
    var arg, values, _i, _len;
    if (this.debug) {
      values = ["Zombie:"];
      if (typeof arguments[0] === "function") {
        try {
          values.push(arguments[0]());
        } catch (ex) {
          values.push(ex);
        }
      } else {
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          values.push(arg);
        }
      }
      return console.log.apply(null, values);
    }
  };

  Browser.prototype.dump = function() {
    var html, indent;
    indent = function(lines) {
      return lines.map(function(l) {
        return "  " + l + "\n";
      }).join("");
    };
    console.log("Zombie: " + VERSION + "\n");
    console.log("URL: " + this.window.location.href);
    console.log("History:\n" + (indent(this.window.history.dump())));
    console.log("Cookies:\n" + (indent(this._cookies.dump())));
    console.log("Storage:\n" + (indent(this._storages.dump())));
    console.log("Eventloop:\n" + (indent(this._eventloop.dump())));
    if (this.document) {
      html = this.document.outerHTML;
      if (html.length > 497) {
        html = html.slice(0, 497) + "...";
      }
      return console.log("Document:\n" + (indent(html.split("\n"))));
    } else {
      if (!this.document) {
        return console.log("No document");
      }
    }
  };

  return Browser;

})(EventEmitter);

Browser.VERSION = VERSION;

module.exports = Browser;
